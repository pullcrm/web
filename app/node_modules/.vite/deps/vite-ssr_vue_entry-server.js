import {
  renderHeadToString
} from "./chunk-U6VZOBDE.js";
import {
  ClientOnly,
  addPagePropsGetterToRoutes,
  createUrl,
  getFullPath,
  provideContext,
  useContext,
  useSsrResponse,
  withoutSuffix
} from "./chunk-JIKA4672.js";
import {
  createMemoryHistory,
  createRouter
} from "./chunk-Y7PJKTNA.js";
import {
  Comment,
  Fragment,
  NOOP,
  Static,
  Text,
  createApp,
  createVNode,
  escapeHtml,
  escapeHtmlComment,
  includeBooleanAttr,
  initDirectivesForSSR,
  isArray,
  isBooleanAttr,
  isFunction,
  isOn,
  isPromise,
  isSSRSafeAttrName,
  isString,
  isVoidTag,
  makeMap,
  mergeProps,
  normalizeClass,
  normalizeStyle,
  propsToAttrMap,
  ssrContextKey,
  ssrUtils,
  stringifyStyle,
  warn
} from "./chunk-KT3I7XAB.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "./chunk-UNANNA3Z.js";

// node_modules/@vue/server-renderer/dist/server-renderer.esm-bundler.js
var shouldIgnoreProp = makeMap(`,key,ref,innerHTML,textContent,ref_key,ref_for`);
function ssrRenderAttrs(props, tag) {
  let ret = "";
  for (const key in props) {
    if (shouldIgnoreProp(key) || isOn(key) || tag === "textarea" && key === "value") {
      continue;
    }
    const value = props[key];
    if (key === "class") {
      ret += ` class="${ssrRenderClass(value)}"`;
    } else if (key === "style") {
      ret += ` style="${ssrRenderStyle(value)}"`;
    } else {
      ret += ssrRenderDynamicAttr(key, value, tag);
    }
  }
  return ret;
}
function ssrRenderDynamicAttr(key, value, tag) {
  if (!isRenderableValue(value)) {
    return ``;
  }
  const attrKey = tag && tag.indexOf("-") > 0 ? key : propsToAttrMap[key] || key.toLowerCase();
  if (isBooleanAttr(attrKey)) {
    return includeBooleanAttr(value) ? ` ${attrKey}` : ``;
  } else if (isSSRSafeAttrName(attrKey)) {
    return value === "" ? ` ${attrKey}` : ` ${attrKey}="${escapeHtml(value)}"`;
  } else {
    console.warn(`[@vue/server-renderer] Skipped rendering unsafe attribute name: ${attrKey}`);
    return ``;
  }
}
function isRenderableValue(value) {
  if (value == null) {
    return false;
  }
  const type = typeof value;
  return type === "string" || type === "number" || type === "boolean";
}
function ssrRenderClass(raw) {
  return escapeHtml(normalizeClass(raw));
}
function ssrRenderStyle(raw) {
  if (!raw) {
    return "";
  }
  if (isString(raw)) {
    return escapeHtml(raw);
  }
  const styles = normalizeStyle(raw);
  return escapeHtml(stringifyStyle(styles));
}
function ssrCompile(template, instance) {
  {
    throw new Error(`On-the-fly template compilation is not supported in the ESM build of @vue/server-renderer. All templates must be pre-compiled into render functions.`);
  }
}
function ssrRenderTeleport(parentPush, contentRenderFn, target, disabled, parentComponent) {
  parentPush("<!--teleport start-->");
  const context = parentComponent.appContext.provides[ssrContextKey];
  const teleportBuffers = context.__teleportBuffers || (context.__teleportBuffers = {});
  const targetBuffer = teleportBuffers[target] || (teleportBuffers[target] = []);
  const bufferIndex = targetBuffer.length;
  let teleportContent;
  if (disabled) {
    contentRenderFn(parentPush);
    teleportContent = `<!--teleport anchor-->`;
  } else {
    const { getBuffer, push } = createBuffer();
    contentRenderFn(push);
    push(`<!--teleport anchor-->`);
    teleportContent = getBuffer();
  }
  targetBuffer.splice(bufferIndex, 0, teleportContent);
  parentPush("<!--teleport end-->");
}
var { createComponentInstance, setCurrentRenderingInstance, setupComponent, renderComponentRoot, normalizeVNode } = ssrUtils;
function createBuffer() {
  let appendable = false;
  const buffer = [];
  return {
    getBuffer() {
      return buffer;
    },
    push(item) {
      const isStringItem = isString(item);
      if (appendable && isStringItem) {
        buffer[buffer.length - 1] += item;
      } else {
        buffer.push(item);
      }
      appendable = isStringItem;
      if (isPromise(item) || isArray(item) && item.hasAsync) {
        buffer.hasAsync = true;
      }
    }
  };
}
function renderComponentVNode(vnode, parentComponent = null, slotScopeId) {
  const instance = createComponentInstance(vnode, parentComponent, null);
  const res = setupComponent(instance, true);
  const hasAsyncSetup = isPromise(res);
  const prefetches = instance.sp;
  if (hasAsyncSetup || prefetches) {
    let p = hasAsyncSetup ? res : Promise.resolve();
    if (prefetches) {
      p = p.then(() => Promise.all(prefetches.map((prefetch) => prefetch.call(instance.proxy)))).catch(() => {
      });
    }
    return p.then(() => renderComponentSubTree(instance, slotScopeId));
  } else {
    return renderComponentSubTree(instance, slotScopeId);
  }
}
function renderComponentSubTree(instance, slotScopeId) {
  const comp = instance.type;
  const { getBuffer, push } = createBuffer();
  if (isFunction(comp)) {
    let root = renderComponentRoot(instance);
    if (!comp.props) {
      for (const key in instance.attrs) {
        if (key.startsWith(`data-v-`)) {
          (root.props || (root.props = {}))[key] = ``;
        }
      }
    }
    renderVNode(push, instance.subTree = root, instance, slotScopeId);
  } else {
    if ((!instance.render || instance.render === NOOP) && !instance.ssrRender && !comp.ssrRender && isString(comp.template)) {
      comp.ssrRender = ssrCompile(comp.template);
    }
    for (const e of instance.scope.effects) {
      if (e.computed)
        e.computed._cacheable = true;
    }
    const ssrRender = instance.ssrRender || comp.ssrRender;
    if (ssrRender) {
      let attrs = instance.inheritAttrs !== false ? instance.attrs : void 0;
      let hasCloned = false;
      let cur = instance;
      while (true) {
        const scopeId = cur.vnode.scopeId;
        if (scopeId) {
          if (!hasCloned) {
            attrs = __spreadValues({}, attrs);
            hasCloned = true;
          }
          attrs[scopeId] = "";
        }
        const parent = cur.parent;
        if (parent && parent.subTree && parent.subTree === cur.vnode) {
          cur = parent;
        } else {
          break;
        }
      }
      if (slotScopeId) {
        if (!hasCloned)
          attrs = __spreadValues({}, attrs);
        attrs[slotScopeId.trim()] = "";
      }
      const prev = setCurrentRenderingInstance(instance);
      ssrRender(instance.proxy, push, instance, attrs, instance.props, instance.setupState, instance.data, instance.ctx);
      setCurrentRenderingInstance(prev);
    } else if (instance.render && instance.render !== NOOP) {
      renderVNode(push, instance.subTree = renderComponentRoot(instance), instance, slotScopeId);
    } else {
      const componentName = comp.name || comp.__file || `<Anonymous>`;
      warn(`Component ${componentName} is missing template or render function.`);
      push(`<!---->`);
    }
  }
  return getBuffer();
}
function renderVNode(push, vnode, parentComponent, slotScopeId) {
  const { type, shapeFlag, children } = vnode;
  switch (type) {
    case Text:
      push(escapeHtml(children));
      break;
    case Comment:
      push(children ? `<!--${escapeHtmlComment(children)}-->` : `<!---->`);
      break;
    case Static:
      push(children);
      break;
    case Fragment:
      if (vnode.slotScopeIds) {
        slotScopeId = (slotScopeId ? slotScopeId + " " : "") + vnode.slotScopeIds.join(" ");
      }
      push(`<!--[-->`);
      renderVNodeChildren(push, children, parentComponent, slotScopeId);
      push(`<!--]-->`);
      break;
    default:
      if (shapeFlag & 1) {
        renderElementVNode(push, vnode, parentComponent, slotScopeId);
      } else if (shapeFlag & 6) {
        push(renderComponentVNode(vnode, parentComponent, slotScopeId));
      } else if (shapeFlag & 64) {
        renderTeleportVNode(push, vnode, parentComponent, slotScopeId);
      } else if (shapeFlag & 128) {
        renderVNode(push, vnode.ssContent, parentComponent, slotScopeId);
      } else {
        warn("[@vue/server-renderer] Invalid VNode type:", type, `(${typeof type})`);
      }
  }
}
function renderVNodeChildren(push, children, parentComponent, slotScopeId) {
  for (let i = 0; i < children.length; i++) {
    renderVNode(push, normalizeVNode(children[i]), parentComponent, slotScopeId);
  }
}
function renderElementVNode(push, vnode, parentComponent, slotScopeId) {
  const tag = vnode.type;
  let { props, children, shapeFlag, scopeId, dirs } = vnode;
  let openTag = `<${tag}`;
  if (dirs) {
    props = applySSRDirectives(vnode, props, dirs);
  }
  if (props) {
    openTag += ssrRenderAttrs(props, tag);
  }
  if (scopeId) {
    openTag += ` ${scopeId}`;
  }
  let curParent = parentComponent;
  let curVnode = vnode;
  while (curParent && curVnode === curParent.subTree) {
    curVnode = curParent.vnode;
    if (curVnode.scopeId) {
      openTag += ` ${curVnode.scopeId}`;
    }
    curParent = curParent.parent;
  }
  if (slotScopeId) {
    openTag += ` ${slotScopeId}`;
  }
  push(openTag + `>`);
  if (!isVoidTag(tag)) {
    let hasChildrenOverride = false;
    if (props) {
      if (props.innerHTML) {
        hasChildrenOverride = true;
        push(props.innerHTML);
      } else if (props.textContent) {
        hasChildrenOverride = true;
        push(escapeHtml(props.textContent));
      } else if (tag === "textarea" && props.value) {
        hasChildrenOverride = true;
        push(escapeHtml(props.value));
      }
    }
    if (!hasChildrenOverride) {
      if (shapeFlag & 8) {
        push(escapeHtml(children));
      } else if (shapeFlag & 16) {
        renderVNodeChildren(push, children, parentComponent, slotScopeId);
      }
    }
    push(`</${tag}>`);
  }
}
function applySSRDirectives(vnode, rawProps, dirs) {
  const toMerge = [];
  for (let i = 0; i < dirs.length; i++) {
    const binding = dirs[i];
    const { dir: { getSSRProps } } = binding;
    if (getSSRProps) {
      const props = getSSRProps(binding, vnode);
      if (props)
        toMerge.push(props);
    }
  }
  return mergeProps(rawProps || {}, ...toMerge);
}
function renderTeleportVNode(push, vnode, parentComponent, slotScopeId) {
  const target = vnode.props && vnode.props.to;
  const disabled = vnode.props && vnode.props.disabled;
  if (!target) {
    if (!disabled) {
      warn(`[@vue/server-renderer] Teleport is missing target prop.`);
    }
    return [];
  }
  if (!isString(target)) {
    warn(`[@vue/server-renderer] Teleport target must be a query selector string.`);
    return [];
  }
  ssrRenderTeleport(push, (push2) => {
    renderVNodeChildren(push2, vnode.children, parentComponent, slotScopeId);
  }, target, disabled || disabled === "", parentComponent);
}
var { isVNode } = ssrUtils;
async function unrollBuffer(buffer) {
  if (buffer.hasAsync) {
    let ret = "";
    for (let i = 0; i < buffer.length; i++) {
      let item = buffer[i];
      if (isPromise(item)) {
        item = await item;
      }
      if (isString(item)) {
        ret += item;
      } else {
        ret += await unrollBuffer(item);
      }
    }
    return ret;
  } else {
    return unrollBufferSync(buffer);
  }
}
function unrollBufferSync(buffer) {
  let ret = "";
  for (let i = 0; i < buffer.length; i++) {
    let item = buffer[i];
    if (isString(item)) {
      ret += item;
    } else {
      ret += unrollBufferSync(item);
    }
  }
  return ret;
}
async function renderToString(input, context = {}) {
  if (isVNode(input)) {
    return renderToString(createApp({ render: () => input }), context);
  }
  const vnode = createVNode(input._component, input._props);
  vnode.appContext = input._context;
  input.provide(ssrContextKey, context);
  const buffer = await renderComponentVNode(vnode);
  const result = await unrollBuffer(buffer);
  await resolveTeleports(context);
  return result;
}
async function resolveTeleports(context) {
  if (context.__teleportBuffers) {
    context.teleports = context.teleports || {};
    for (const key in context.__teleportBuffers) {
      context.teleports[key] = await unrollBuffer(await Promise.all(context.__teleportBuffers[key]));
    }
  }
}
var { isVNode: isVNode$1 } = ssrUtils;
initDirectivesForSSR();

// node_modules/vite-ssr/utils/serialize-state.js
var UNSAFE_CHARS_REGEXP = /[<>\/\u2028\u2029]/g;
var ESCAPED_CHARS = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
function escapeUnsafeChars(unsafeChar) {
  return ESCAPED_CHARS[unsafeChar];
}
function serializeState(state) {
  try {
    state = JSON.stringify(state || {}).replace(/\\/g, String.raw`\\`).replace(/'/g, String.raw`\'`).replace(UNSAFE_CHARS_REGEXP, escapeUnsafeChars);
    return `'${state}'`;
  } catch (error) {
    console.error("[SSR] On state serialization -", error, state);
    return "{}";
  }
}

// node_modules/vite-ssr/utils/html.js
function findDependencies(modules, manifest) {
  const files = /* @__PURE__ */ new Set();
  for (const id of modules || []) {
    for (const file of manifest[id] || []) {
      files.add(file);
    }
  }
  return [...files];
}
function renderPreloadLinks(files) {
  let link = "";
  for (const file of files || []) {
    if (file.endsWith(".js")) {
      link += `<link rel="modulepreload" crossorigin href="${file}">`;
    } else if (file.endsWith(".css")) {
      link += `<link rel="stylesheet" href="${file}">`;
    }
  }
  return link;
}
var containerId = "app";
var containerRE = new RegExp(`<div id="${containerId}"([\\s\\w\\-"'=[\\]]*)><\\/div>`);
function buildHtmlDocument(template, { htmlAttrs, bodyAttrs, headTags, body, initialState }) {
  if (true) {
    if (template.indexOf(`id="${containerId}"`) === -1) {
      console.warn(`[SSR] Container with id "${containerId}" was not found in index.html`);
    }
  }
  if (htmlAttrs) {
    template = template.replace("<html", `<html ${htmlAttrs} `);
  }
  if (bodyAttrs) {
    template = template.replace("<body", `<body ${bodyAttrs} `);
  }
  if (headTags) {
    template = template.replace("</head>", `
${headTags}
</head>`);
  }
  return template.replace(containerRE, (_, d1) => `<div id="${containerId}" data-server-rendered="true"${d1 || ""}>${body || ""}</div>

  <script>window.__INITIAL_STATE__=${initialState || "'{}'"}<\/script>`);
}

// node_modules/vite-ssr/core/entry-server.js
var getEmptyHtmlParts = () => ({
  headTags: "",
  htmlAttrs: "",
  bodyAttrs: "",
  body: "",
  initialState: void 0,
  dependencies: []
});
var viteSSR = function viteSSR2(options, hook) {
  const renderer = hook || options;
  const { transformState = serializeState } = options;
  return async function(url, _a = {}) {
    var _b = _a, {
      manifest,
      preload = false,
      skip = false,
      template = `__VITE_SSR_HTML__`
    } = _b, extra = __objRest(_b, [
      "manifest",
      "preload",
      "skip",
      "template"
    ]);
    if (skip) {
      return __spreadValues({ html: template }, getEmptyHtmlParts());
    }
    url = createUrl(url);
    const { deferred, response, writeResponse, redirect, isRedirect } = useSsrResponse();
    const context = __spreadValues({
      url,
      isClient: false,
      initialState: {},
      redirect,
      writeResponse
    }, extra);
    const payload = await Promise.race([
      renderer(context, __spreadProps(__spreadValues({}, extra), { isRedirect })),
      deferred.promise
    ]);
    if (isRedirect())
      return response;
    const htmlParts = __spreadProps(__spreadValues(__spreadValues({}, getEmptyHtmlParts()), payload), {
      initialState: await transformState(context.initialState || {}, serializeState)
    });
    if (manifest) {
      htmlParts.dependencies = findDependencies(context.modules, manifest);
      if (preload && htmlParts.dependencies.length > 0) {
        htmlParts.headTags += renderPreloadLinks(htmlParts.dependencies);
      }
    }
    return __spreadValues(__spreadValues({
      html: buildHtmlDocument(template, htmlParts)
    }, htmlParts), response);
  };
};
var entry_server_default = viteSSR;

// node_modules/vite-ssr/vue/entry-server.js
var viteSSR3 = function viteSSR4(App, _a, hook) {
  var _b = _a, { routes, base, routerOptions = {}, pageProps = { passToPage: true } } = _b, options = __objRest(_b, ["routes", "base", "routerOptions", "pageProps"]);
  if (pageProps && pageProps.passToPage) {
    addPagePropsGetterToRoutes(routes);
  }
  return entry_server_default(options, async (context, _a2) => {
    var _b2 = _a2, { isRedirect } = _b2, extra = __objRest(_b2, ["isRedirect"]);
    const app = createApp(App);
    const routeBase = base && withoutSuffix(base(context), "/");
    const router = createRouter(__spreadProps(__spreadValues({}, routerOptions), {
      history: createMemoryHistory(routeBase),
      routes
    }));
    router.beforeEach((to) => {
      to.meta.state = extra.initialState || null;
    });
    provideContext(app, context);
    const fullPath = getFullPath(context.url, routeBase);
    const { head } = hook && await hook(__spreadValues({
      app,
      router,
      initialRoute: router.resolve(fullPath)
    }, context)) || {};
    app.use(router);
    router.push(fullPath);
    await router.isReady();
    if (isRedirect())
      return {};
    Object.assign(context.initialState || {}, (router.currentRoute.value.meta || {}).state || {});
    const body = await renderToString(app, context);
    if (isRedirect())
      return {};
    const { headTags = "", htmlAttrs = "", bodyAttrs = "" } = head ? renderHeadToString(head) : {};
    return { body, headTags, htmlAttrs, bodyAttrs };
  });
};
var entry_server_default2 = viteSSR3;

// dep:vite-ssr_vue_entry-server
var vite_ssr_vue_entry_server_default = entry_server_default2;
export {
  ClientOnly,
  vite_ssr_vue_entry_server_default as default,
  useContext,
  viteSSR3 as viteSSR
};
//# sourceMappingURL=vite-ssr_vue_entry-server.js.map
