{
  "version": 3,
  "sources": ["../../@vue/server-renderer/dist/server-renderer.esm-bundler.js", "../../vite-ssr/utils/serialize-state.js", "../../vite-ssr/utils/html.js", "../../vite-ssr/core/entry-server.js", "../../vite-ssr/vue/entry-server.js", "dep:vite-ssr_vue_entry-server"],
  "sourcesContent": ["import { ssrContextKey, warn as warn$1, Fragment, Static, Comment, Text, mergeProps, ssrUtils, createApp, createVNode, initDirectivesForSSR } from 'vue';\nimport { makeMap, isOn, escapeHtml, normalizeClass, propsToAttrMap, isBooleanAttr, includeBooleanAttr, isSSRSafeAttrName, isString, normalizeStyle, stringifyStyle, escapeHtmlComment, isVoidTag, isPromise, isArray, isFunction, NOOP, toDisplayString, isObject, looseEqual, looseIndexOf } from '@vue/shared';\nexport { includeBooleanAttr as ssrIncludeBooleanAttr } from '@vue/shared';\n\n// leading comma for empty string \"\"\r\nconst shouldIgnoreProp = makeMap(`,key,ref,innerHTML,textContent,ref_key,ref_for`);\r\nfunction ssrRenderAttrs(props, tag) {\r\n    let ret = '';\r\n    for (const key in props) {\r\n        if (shouldIgnoreProp(key) ||\r\n            isOn(key) ||\r\n            (tag === 'textarea' && key === 'value')) {\r\n            continue;\r\n        }\r\n        const value = props[key];\r\n        if (key === 'class') {\r\n            ret += ` class=\"${ssrRenderClass(value)}\"`;\r\n        }\r\n        else if (key === 'style') {\r\n            ret += ` style=\"${ssrRenderStyle(value)}\"`;\r\n        }\r\n        else {\r\n            ret += ssrRenderDynamicAttr(key, value, tag);\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n// render an attr with dynamic (unknown) key.\r\nfunction ssrRenderDynamicAttr(key, value, tag) {\r\n    if (!isRenderableValue(value)) {\r\n        return ``;\r\n    }\r\n    const attrKey = tag && tag.indexOf('-') > 0\r\n        ? key // preserve raw name on custom elements\r\n        : propsToAttrMap[key] || key.toLowerCase();\r\n    if (isBooleanAttr(attrKey)) {\r\n        return includeBooleanAttr(value) ? ` ${attrKey}` : ``;\r\n    }\r\n    else if (isSSRSafeAttrName(attrKey)) {\r\n        return value === '' ? ` ${attrKey}` : ` ${attrKey}=\"${escapeHtml(value)}\"`;\r\n    }\r\n    else {\r\n        console.warn(`[@vue/server-renderer] Skipped rendering unsafe attribute name: ${attrKey}`);\r\n        return ``;\r\n    }\r\n}\r\n// Render a v-bind attr with static key. The key is pre-processed at compile\r\n// time and we only need to check and escape value.\r\nfunction ssrRenderAttr(key, value) {\r\n    if (!isRenderableValue(value)) {\r\n        return ``;\r\n    }\r\n    return ` ${key}=\"${escapeHtml(value)}\"`;\r\n}\r\nfunction isRenderableValue(value) {\r\n    if (value == null) {\r\n        return false;\r\n    }\r\n    const type = typeof value;\r\n    return type === 'string' || type === 'number' || type === 'boolean';\r\n}\r\nfunction ssrRenderClass(raw) {\r\n    return escapeHtml(normalizeClass(raw));\r\n}\r\nfunction ssrRenderStyle(raw) {\r\n    if (!raw) {\r\n        return '';\r\n    }\r\n    if (isString(raw)) {\r\n        return escapeHtml(raw);\r\n    }\r\n    const styles = normalizeStyle(raw);\r\n    return escapeHtml(stringifyStyle(styles));\r\n}\n\nfunction ssrCompile(template, instance) {\r\n    {\r\n        throw new Error(`On-the-fly template compilation is not supported in the ESM build of ` +\r\n            `@vue/server-renderer. All templates must be pre-compiled into ` +\r\n            `render functions.`);\r\n    }\r\n}\n\nfunction ssrRenderTeleport(parentPush, contentRenderFn, target, disabled, parentComponent) {\r\n    parentPush('<!--teleport start-->');\r\n    const context = parentComponent.appContext.provides[ssrContextKey];\r\n    const teleportBuffers = context.__teleportBuffers || (context.__teleportBuffers = {});\r\n    const targetBuffer = teleportBuffers[target] || (teleportBuffers[target] = []);\r\n    // record current index of the target buffer to handle nested teleports\r\n    // since the parent needs to be rendered before the child\r\n    const bufferIndex = targetBuffer.length;\r\n    let teleportContent;\r\n    if (disabled) {\r\n        contentRenderFn(parentPush);\r\n        teleportContent = `<!--teleport anchor-->`;\r\n    }\r\n    else {\r\n        const { getBuffer, push } = createBuffer();\r\n        contentRenderFn(push);\r\n        push(`<!--teleport anchor-->`);\r\n        teleportContent = getBuffer();\r\n    }\r\n    targetBuffer.splice(bufferIndex, 0, teleportContent);\r\n    parentPush('<!--teleport end-->');\r\n}\n\nconst { createComponentInstance, setCurrentRenderingInstance, setupComponent, renderComponentRoot, normalizeVNode } = ssrUtils;\r\n// Each component has a buffer array.\r\n// A buffer array can contain one of the following:\r\n// - plain string\r\n// - A resolved buffer (recursive arrays of strings that can be unrolled\r\n//   synchronously)\r\n// - An async buffer (a Promise that resolves to a resolved buffer)\r\nfunction createBuffer() {\r\n    let appendable = false;\r\n    const buffer = [];\r\n    return {\r\n        getBuffer() {\r\n            // Return static buffer and await on items during unroll stage\r\n            return buffer;\r\n        },\r\n        push(item) {\r\n            const isStringItem = isString(item);\r\n            if (appendable && isStringItem) {\r\n                buffer[buffer.length - 1] += item;\r\n            }\r\n            else {\r\n                buffer.push(item);\r\n            }\r\n            appendable = isStringItem;\r\n            if (isPromise(item) || (isArray(item) && item.hasAsync)) {\r\n                // promise, or child buffer with async, mark as async.\r\n                // this allows skipping unnecessary await ticks during unroll stage\r\n                buffer.hasAsync = true;\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction renderComponentVNode(vnode, parentComponent = null, slotScopeId) {\r\n    const instance = createComponentInstance(vnode, parentComponent, null);\r\n    const res = setupComponent(instance, true /* isSSR */);\r\n    const hasAsyncSetup = isPromise(res);\r\n    const prefetches = instance.sp; /* LifecycleHooks.SERVER_PREFETCH */\r\n    if (hasAsyncSetup || prefetches) {\r\n        let p = hasAsyncSetup\r\n            ? res\r\n            : Promise.resolve();\r\n        if (prefetches) {\r\n            p = p\r\n                .then(() => Promise.all(prefetches.map(prefetch => prefetch.call(instance.proxy))))\r\n                // Note: error display is already done by the wrapped lifecycle hook function.\r\n                .catch(() => { });\r\n        }\r\n        return p.then(() => renderComponentSubTree(instance, slotScopeId));\r\n    }\r\n    else {\r\n        return renderComponentSubTree(instance, slotScopeId);\r\n    }\r\n}\r\nfunction renderComponentSubTree(instance, slotScopeId) {\r\n    const comp = instance.type;\r\n    const { getBuffer, push } = createBuffer();\r\n    if (isFunction(comp)) {\r\n        let root = renderComponentRoot(instance);\r\n        // #5817 scope ID attrs not falling through if functional component doesn't\r\n        // have props\r\n        if (!comp.props) {\r\n            for (const key in instance.attrs) {\r\n                if (key.startsWith(`data-v-`)) {\r\n                    (root.props || (root.props = {}))[key] = ``;\r\n                }\r\n            }\r\n        }\r\n        renderVNode(push, (instance.subTree = root), instance, slotScopeId);\r\n    }\r\n    else {\r\n        if ((!instance.render || instance.render === NOOP) &&\r\n            !instance.ssrRender &&\r\n            !comp.ssrRender &&\r\n            isString(comp.template)) {\r\n            comp.ssrRender = ssrCompile(comp.template);\r\n        }\r\n        // perf: enable caching of computed getters during render\r\n        // since there cannot be state mutations during render.\r\n        for (const e of instance.scope.effects) {\r\n            if (e.computed)\r\n                e.computed._cacheable = true;\r\n        }\r\n        const ssrRender = instance.ssrRender || comp.ssrRender;\r\n        if (ssrRender) {\r\n            // optimized\r\n            // resolve fallthrough attrs\r\n            let attrs = instance.inheritAttrs !== false ? instance.attrs : undefined;\r\n            let hasCloned = false;\r\n            let cur = instance;\r\n            while (true) {\r\n                const scopeId = cur.vnode.scopeId;\r\n                if (scopeId) {\r\n                    if (!hasCloned) {\r\n                        attrs = { ...attrs };\r\n                        hasCloned = true;\r\n                    }\r\n                    attrs[scopeId] = '';\r\n                }\r\n                const parent = cur.parent;\r\n                if (parent && parent.subTree && parent.subTree === cur.vnode) {\r\n                    // parent is a non-SSR compiled component and is rendering this\r\n                    // component as root. inherit its scopeId if present.\r\n                    cur = parent;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            if (slotScopeId) {\r\n                if (!hasCloned)\r\n                    attrs = { ...attrs };\r\n                attrs[slotScopeId.trim()] = '';\r\n            }\r\n            // set current rendering instance for asset resolution\r\n            const prev = setCurrentRenderingInstance(instance);\r\n            ssrRender(instance.proxy, push, instance, attrs, \r\n            // compiler-optimized bindings\r\n            instance.props, instance.setupState, instance.data, instance.ctx);\r\n            setCurrentRenderingInstance(prev);\r\n        }\r\n        else if (instance.render && instance.render !== NOOP) {\r\n            renderVNode(push, (instance.subTree = renderComponentRoot(instance)), instance, slotScopeId);\r\n        }\r\n        else {\r\n            const componentName = comp.name || comp.__file || `<Anonymous>`;\r\n            warn$1(`Component ${componentName} is missing template or render function.`);\r\n            push(`<!---->`);\r\n        }\r\n    }\r\n    return getBuffer();\r\n}\r\nfunction renderVNode(push, vnode, parentComponent, slotScopeId) {\r\n    const { type, shapeFlag, children } = vnode;\r\n    switch (type) {\r\n        case Text:\r\n            push(escapeHtml(children));\r\n            break;\r\n        case Comment:\r\n            push(children ? `<!--${escapeHtmlComment(children)}-->` : `<!---->`);\r\n            break;\r\n        case Static:\r\n            push(children);\r\n            break;\r\n        case Fragment:\r\n            if (vnode.slotScopeIds) {\r\n                slotScopeId =\r\n                    (slotScopeId ? slotScopeId + ' ' : '') + vnode.slotScopeIds.join(' ');\r\n            }\r\n            push(`<!--[-->`); // open\r\n            renderVNodeChildren(push, children, parentComponent, slotScopeId);\r\n            push(`<!--]-->`); // close\r\n            break;\r\n        default:\r\n            if (shapeFlag & 1 /* ELEMENT */) {\r\n                renderElementVNode(push, vnode, parentComponent, slotScopeId);\r\n            }\r\n            else if (shapeFlag & 6 /* COMPONENT */) {\r\n                push(renderComponentVNode(vnode, parentComponent, slotScopeId));\r\n            }\r\n            else if (shapeFlag & 64 /* TELEPORT */) {\r\n                renderTeleportVNode(push, vnode, parentComponent, slotScopeId);\r\n            }\r\n            else if (shapeFlag & 128 /* SUSPENSE */) {\r\n                renderVNode(push, vnode.ssContent, parentComponent, slotScopeId);\r\n            }\r\n            else {\r\n                warn$1('[@vue/server-renderer] Invalid VNode type:', type, `(${typeof type})`);\r\n            }\r\n    }\r\n}\r\nfunction renderVNodeChildren(push, children, parentComponent, slotScopeId) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        renderVNode(push, normalizeVNode(children[i]), parentComponent, slotScopeId);\r\n    }\r\n}\r\nfunction renderElementVNode(push, vnode, parentComponent, slotScopeId) {\r\n    const tag = vnode.type;\r\n    let { props, children, shapeFlag, scopeId, dirs } = vnode;\r\n    let openTag = `<${tag}`;\r\n    if (dirs) {\r\n        props = applySSRDirectives(vnode, props, dirs);\r\n    }\r\n    if (props) {\r\n        openTag += ssrRenderAttrs(props, tag);\r\n    }\r\n    if (scopeId) {\r\n        openTag += ` ${scopeId}`;\r\n    }\r\n    // inherit parent chain scope id if this is the root node\r\n    let curParent = parentComponent;\r\n    let curVnode = vnode;\r\n    while (curParent && curVnode === curParent.subTree) {\r\n        curVnode = curParent.vnode;\r\n        if (curVnode.scopeId) {\r\n            openTag += ` ${curVnode.scopeId}`;\r\n        }\r\n        curParent = curParent.parent;\r\n    }\r\n    if (slotScopeId) {\r\n        openTag += ` ${slotScopeId}`;\r\n    }\r\n    push(openTag + `>`);\r\n    if (!isVoidTag(tag)) {\r\n        let hasChildrenOverride = false;\r\n        if (props) {\r\n            if (props.innerHTML) {\r\n                hasChildrenOverride = true;\r\n                push(props.innerHTML);\r\n            }\r\n            else if (props.textContent) {\r\n                hasChildrenOverride = true;\r\n                push(escapeHtml(props.textContent));\r\n            }\r\n            else if (tag === 'textarea' && props.value) {\r\n                hasChildrenOverride = true;\r\n                push(escapeHtml(props.value));\r\n            }\r\n        }\r\n        if (!hasChildrenOverride) {\r\n            if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                push(escapeHtml(children));\r\n            }\r\n            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                renderVNodeChildren(push, children, parentComponent, slotScopeId);\r\n            }\r\n        }\r\n        push(`</${tag}>`);\r\n    }\r\n}\r\nfunction applySSRDirectives(vnode, rawProps, dirs) {\r\n    const toMerge = [];\r\n    for (let i = 0; i < dirs.length; i++) {\r\n        const binding = dirs[i];\r\n        const { dir: { getSSRProps } } = binding;\r\n        if (getSSRProps) {\r\n            const props = getSSRProps(binding, vnode);\r\n            if (props)\r\n                toMerge.push(props);\r\n        }\r\n    }\r\n    return mergeProps(rawProps || {}, ...toMerge);\r\n}\r\nfunction renderTeleportVNode(push, vnode, parentComponent, slotScopeId) {\r\n    const target = vnode.props && vnode.props.to;\r\n    const disabled = vnode.props && vnode.props.disabled;\r\n    if (!target) {\r\n        if (!disabled) {\r\n            warn$1(`[@vue/server-renderer] Teleport is missing target prop.`);\r\n        }\r\n        return [];\r\n    }\r\n    if (!isString(target)) {\r\n        warn$1(`[@vue/server-renderer] Teleport target must be a query selector string.`);\r\n        return [];\r\n    }\r\n    ssrRenderTeleport(push, push => {\r\n        renderVNodeChildren(push, vnode.children, parentComponent, slotScopeId);\r\n    }, target, disabled || disabled === '', parentComponent);\r\n}\n\nconst { isVNode } = ssrUtils;\r\nasync function unrollBuffer(buffer) {\r\n    if (buffer.hasAsync) {\r\n        let ret = '';\r\n        for (let i = 0; i < buffer.length; i++) {\r\n            let item = buffer[i];\r\n            if (isPromise(item)) {\r\n                item = await item;\r\n            }\r\n            if (isString(item)) {\r\n                ret += item;\r\n            }\r\n            else {\r\n                ret += await unrollBuffer(item);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    else {\r\n        // sync buffer can be more efficiently unrolled without unnecessary await\r\n        // ticks\r\n        return unrollBufferSync(buffer);\r\n    }\r\n}\r\nfunction unrollBufferSync(buffer) {\r\n    let ret = '';\r\n    for (let i = 0; i < buffer.length; i++) {\r\n        let item = buffer[i];\r\n        if (isString(item)) {\r\n            ret += item;\r\n        }\r\n        else {\r\n            // since this is a sync buffer, child buffers are never promises\r\n            ret += unrollBufferSync(item);\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nasync function renderToString(input, context = {}) {\r\n    if (isVNode(input)) {\r\n        // raw vnode, wrap with app (for context)\r\n        return renderToString(createApp({ render: () => input }), context);\r\n    }\r\n    // rendering an app\r\n    const vnode = createVNode(input._component, input._props);\r\n    vnode.appContext = input._context;\r\n    // provide the ssr context to the tree\r\n    input.provide(ssrContextKey, context);\r\n    const buffer = await renderComponentVNode(vnode);\r\n    const result = await unrollBuffer(buffer);\r\n    await resolveTeleports(context);\r\n    return result;\r\n}\r\nasync function resolveTeleports(context) {\r\n    if (context.__teleportBuffers) {\r\n        context.teleports = context.teleports || {};\r\n        for (const key in context.__teleportBuffers) {\r\n            // note: it's OK to await sequentially here because the Promises were\r\n            // created eagerly in parallel.\r\n            context.teleports[key] = await unrollBuffer((await Promise.all(context.__teleportBuffers[key])));\r\n        }\r\n    }\r\n}\n\nconst { isVNode: isVNode$1 } = ssrUtils;\r\nasync function unrollBuffer$1(buffer, stream) {\r\n    if (buffer.hasAsync) {\r\n        for (let i = 0; i < buffer.length; i++) {\r\n            let item = buffer[i];\r\n            if (isPromise(item)) {\r\n                item = await item;\r\n            }\r\n            if (isString(item)) {\r\n                stream.push(item);\r\n            }\r\n            else {\r\n                await unrollBuffer$1(item, stream);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // sync buffer can be more efficiently unrolled without unnecessary await\r\n        // ticks\r\n        unrollBufferSync$1(buffer, stream);\r\n    }\r\n}\r\nfunction unrollBufferSync$1(buffer, stream) {\r\n    for (let i = 0; i < buffer.length; i++) {\r\n        let item = buffer[i];\r\n        if (isString(item)) {\r\n            stream.push(item);\r\n        }\r\n        else {\r\n            // since this is a sync buffer, child buffers are never promises\r\n            unrollBufferSync$1(item, stream);\r\n        }\r\n    }\r\n}\r\nfunction renderToSimpleStream(input, context, stream) {\r\n    if (isVNode$1(input)) {\r\n        // raw vnode, wrap with app (for context)\r\n        return renderToSimpleStream(createApp({ render: () => input }), context, stream);\r\n    }\r\n    // rendering an app\r\n    const vnode = createVNode(input._component, input._props);\r\n    vnode.appContext = input._context;\r\n    // provide the ssr context to the tree\r\n    input.provide(ssrContextKey, context);\r\n    Promise.resolve(renderComponentVNode(vnode))\r\n        .then(buffer => unrollBuffer$1(buffer, stream))\r\n        .then(() => resolveTeleports(context))\r\n        .then(() => stream.push(null))\r\n        .catch(error => {\r\n        stream.destroy(error);\r\n    });\r\n    return stream;\r\n}\r\n/**\r\n * @deprecated\r\n */\r\nfunction renderToStream(input, context = {}) {\r\n    console.warn(`[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead.`);\r\n    return renderToNodeStream(input, context);\r\n}\r\nfunction renderToNodeStream(input, context = {}) {\r\n    const stream = null;\r\n    {\r\n        throw new Error(`ESM build of renderToStream() does not support renderToNodeStream(). ` +\r\n            `Use pipeToNodeWritable() with an existing Node.js Writable stream ` +\r\n            `instance instead.`);\r\n    }\r\n}\r\nfunction pipeToNodeWritable(input, context = {}, writable) {\r\n    renderToSimpleStream(input, context, {\r\n        push(content) {\r\n            if (content != null) {\r\n                writable.write(content);\r\n            }\r\n            else {\r\n                writable.end();\r\n            }\r\n        },\r\n        destroy(err) {\r\n            writable.destroy(err);\r\n        }\r\n    });\r\n}\r\nfunction renderToWebStream(input, context = {}) {\r\n    if (typeof ReadableStream !== 'function') {\r\n        throw new Error(`ReadableStream constructor is not available in the global scope. ` +\r\n            `If the target environment does support web streams, consider using ` +\r\n            `pipeToWebWritable() with an existing WritableStream instance instead.`);\r\n    }\r\n    const encoder = new TextEncoder();\r\n    let cancelled = false;\r\n    return new ReadableStream({\r\n        start(controller) {\r\n            renderToSimpleStream(input, context, {\r\n                push(content) {\r\n                    if (cancelled)\r\n                        return;\r\n                    if (content != null) {\r\n                        controller.enqueue(encoder.encode(content));\r\n                    }\r\n                    else {\r\n                        controller.close();\r\n                    }\r\n                },\r\n                destroy(err) {\r\n                    controller.error(err);\r\n                }\r\n            });\r\n        },\r\n        cancel() {\r\n            cancelled = true;\r\n        }\r\n    });\r\n}\r\nfunction pipeToWebWritable(input, context = {}, writable) {\r\n    const writer = writable.getWriter();\r\n    const encoder = new TextEncoder();\r\n    // #4287 CloudFlare workers do not implement `ready` property\r\n    let hasReady = false;\r\n    try {\r\n        hasReady = isPromise(writer.ready);\r\n    }\r\n    catch (e) { }\r\n    renderToSimpleStream(input, context, {\r\n        async push(content) {\r\n            if (hasReady) {\r\n                await writer.ready;\r\n            }\r\n            if (content != null) {\r\n                return writer.write(encoder.encode(content));\r\n            }\r\n            else {\r\n                return writer.close();\r\n            }\r\n        },\r\n        destroy(err) {\r\n            // TODO better error handling?\r\n            console.log(err);\r\n            writer.close();\r\n        }\r\n    });\r\n}\n\nfunction ssrRenderComponent(comp, props = null, children = null, parentComponent = null, slotScopeId) {\r\n    return renderComponentVNode(createVNode(comp, props, children), parentComponent, slotScopeId);\r\n}\n\nfunction ssrRenderSlot(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId) {\r\n    // template-compiled slots are always rendered as fragments\r\n    push(`<!--[-->`);\r\n    ssrRenderSlotInner(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId);\r\n    push(`<!--]-->`);\r\n}\r\nfunction ssrRenderSlotInner(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId) {\r\n    const slotFn = slots[slotName];\r\n    if (slotFn) {\r\n        const slotBuffer = [];\r\n        const bufferedPush = (item) => {\r\n            slotBuffer.push(item);\r\n        };\r\n        const ret = slotFn(slotProps, bufferedPush, parentComponent, slotScopeId ? ' ' + slotScopeId : '');\r\n        if (isArray(ret)) {\r\n            // normal slot\r\n            renderVNodeChildren(push, ret, parentComponent, slotScopeId);\r\n        }\r\n        else {\r\n            // ssr slot.\r\n            // check if the slot renders all comments, in which case use the fallback\r\n            let isEmptySlot = true;\r\n            for (let i = 0; i < slotBuffer.length; i++) {\r\n                if (!isComment(slotBuffer[i])) {\r\n                    isEmptySlot = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (isEmptySlot) {\r\n                if (fallbackRenderFn) {\r\n                    fallbackRenderFn();\r\n                }\r\n            }\r\n            else {\r\n                for (let i = 0; i < slotBuffer.length; i++) {\r\n                    push(slotBuffer[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (fallbackRenderFn) {\r\n        fallbackRenderFn();\r\n    }\r\n}\r\nconst commentRE = /<!--[^]*?-->/gm;\r\nfunction isComment(item) {\r\n    return (typeof item === 'string' &&\r\n        commentRE.test(item) &&\r\n        !item.replace(commentRE, '').trim());\r\n}\n\nfunction ssrInterpolate(value) {\r\n    return escapeHtml(toDisplayString(value));\r\n}\n\nfunction toRaw(observed) {\r\n    const raw = observed && observed[\"__v_raw\" /* RAW */];\r\n    return raw ? toRaw(raw) : observed;\r\n}\n\nfunction isRef(r) {\r\n    return !!(r && r.__v_isRef === true);\r\n}\n\nconst stack = [];\r\nfunction pushWarningContext(vnode) {\r\n    stack.push(vnode);\r\n}\r\nfunction popWarningContext() {\r\n    stack.pop();\r\n}\r\nfunction warn(msg, ...args) {\r\n    const instance = stack.length ? stack[stack.length - 1].component : null;\r\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\r\n    const trace = getComponentTrace();\r\n    if (appWarnHandler) {\r\n        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [\r\n            msg + args.join(''),\r\n            instance && instance.proxy,\r\n            trace\r\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\r\n                .join('\\n'),\r\n            trace\r\n        ]);\r\n    }\r\n    else {\r\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\r\n        /* istanbul ignore if */\r\n        if (trace.length &&\r\n            // avoid spamming console during tests\r\n            !false) {\r\n            warnArgs.push(`\\n`, ...formatTrace(trace));\r\n        }\r\n        console.warn(...warnArgs);\r\n    }\r\n}\r\nfunction getComponentTrace() {\r\n    let currentVNode = stack[stack.length - 1];\r\n    if (!currentVNode) {\r\n        return [];\r\n    }\r\n    // we can't just use the stack because it will be incomplete during updates\r\n    // that did not start from the root. Re-construct the parent chain using\r\n    // instance parent pointers.\r\n    const normalizedStack = [];\r\n    while (currentVNode) {\r\n        const last = normalizedStack[0];\r\n        if (last && last.vnode === currentVNode) {\r\n            last.recurseCount++;\r\n        }\r\n        else {\r\n            normalizedStack.push({\r\n                vnode: currentVNode,\r\n                recurseCount: 0\r\n            });\r\n        }\r\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\r\n        currentVNode = parentInstance && parentInstance.vnode;\r\n    }\r\n    return normalizedStack;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatTrace(trace) {\r\n    const logs = [];\r\n    trace.forEach((entry, i) => {\r\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\r\n    });\r\n    return logs;\r\n}\r\nfunction formatTraceEntry({ vnode, recurseCount }) {\r\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\r\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\r\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\r\n    const close = `>` + postfix;\r\n    return vnode.props\r\n        ? [open, ...formatProps(vnode.props), close]\r\n        : [open + close];\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProps(props) {\r\n    const res = [];\r\n    const keys = Object.keys(props);\r\n    keys.slice(0, 3).forEach(key => {\r\n        res.push(...formatProp(key, props[key]));\r\n    });\r\n    if (keys.length > 3) {\r\n        res.push(` ...`);\r\n    }\r\n    return res;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProp(key, value, raw) {\r\n    if (isString(value)) {\r\n        value = JSON.stringify(value);\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (typeof value === 'number' ||\r\n        typeof value === 'boolean' ||\r\n        value == null) {\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (isRef(value)) {\r\n        value = formatProp(key, toRaw(value.value), true);\r\n        return raw ? value : [`${key}=Ref<`, value, `>`];\r\n    }\r\n    else if (isFunction(value)) {\r\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\r\n    }\r\n    else {\r\n        value = toRaw(value);\r\n        return raw ? value : [`${key}=`, value];\r\n    }\r\n}\n\nconst ErrorTypeStrings = {\r\n    [\"sp\" /* SERVER_PREFETCH */]: 'serverPrefetch hook',\r\n    [\"bc\" /* BEFORE_CREATE */]: 'beforeCreate hook',\r\n    [\"c\" /* CREATED */]: 'created hook',\r\n    [\"bm\" /* BEFORE_MOUNT */]: 'beforeMount hook',\r\n    [\"m\" /* MOUNTED */]: 'mounted hook',\r\n    [\"bu\" /* BEFORE_UPDATE */]: 'beforeUpdate hook',\r\n    [\"u\" /* UPDATED */]: 'updated',\r\n    [\"bum\" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',\r\n    [\"um\" /* UNMOUNTED */]: 'unmounted hook',\r\n    [\"a\" /* ACTIVATED */]: 'activated hook',\r\n    [\"da\" /* DEACTIVATED */]: 'deactivated hook',\r\n    [\"ec\" /* ERROR_CAPTURED */]: 'errorCaptured hook',\r\n    [\"rtc\" /* RENDER_TRACKED */]: 'renderTracked hook',\r\n    [\"rtg\" /* RENDER_TRIGGERED */]: 'renderTriggered hook',\r\n    [0 /* SETUP_FUNCTION */]: 'setup function',\r\n    [1 /* RENDER_FUNCTION */]: 'render function',\r\n    [2 /* WATCH_GETTER */]: 'watcher getter',\r\n    [3 /* WATCH_CALLBACK */]: 'watcher callback',\r\n    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',\r\n    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',\r\n    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',\r\n    [7 /* VNODE_HOOK */]: 'vnode hook',\r\n    [8 /* DIRECTIVE_HOOK */]: 'directive hook',\r\n    [9 /* TRANSITION_HOOK */]: 'transition hook',\r\n    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',\r\n    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',\r\n    [12 /* FUNCTION_REF */]: 'ref function',\r\n    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',\r\n    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +\r\n        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'\r\n};\r\nfunction callWithErrorHandling(fn, instance, type, args) {\r\n    let res;\r\n    try {\r\n        res = args ? fn(...args) : fn();\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, type);\r\n    }\r\n    return res;\r\n}\r\nfunction handleError(err, instance, type, throwInDev = true) {\r\n    const contextVNode = instance ? instance.vnode : null;\r\n    if (instance) {\r\n        let cur = instance.parent;\r\n        // the exposed instance is the render proxy to keep it consistent with 2.x\r\n        const exposedInstance = instance.proxy;\r\n        // in production the hook receives only the error code\r\n        const errorInfo = (process.env.NODE_ENV !== 'production') ? ErrorTypeStrings[type] : type;\r\n        while (cur) {\r\n            const errorCapturedHooks = cur.ec;\r\n            if (errorCapturedHooks) {\r\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            cur = cur.parent;\r\n        }\r\n        // app-level handling\r\n        const appErrorHandler = instance.appContext.config.errorHandler;\r\n        if (appErrorHandler) {\r\n            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\r\n            return;\r\n        }\r\n    }\r\n    logError(err, type, contextVNode, throwInDev);\r\n}\r\nfunction logError(err, type, contextVNode, throwInDev = true) {\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const info = ErrorTypeStrings[type];\r\n        if (contextVNode) {\r\n            pushWarningContext(contextVNode);\r\n        }\r\n        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\r\n        if (contextVNode) {\r\n            popWarningContext();\r\n        }\r\n        // crash in dev by default so it's more noticeable\r\n        if (throwInDev) {\r\n            throw err;\r\n        }\r\n        else {\r\n            console.error(err);\r\n        }\r\n    }\r\n    else {\r\n        // recover in prod to reduce the impact on end-user\r\n        console.error(err);\r\n    }\r\n}\n\nconst classifyRE = /(?:^|[-_])(\\w)/g;\r\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\r\nfunction getComponentName(Component) {\r\n    return isFunction(Component)\r\n        ? Component.displayName || Component.name\r\n        : Component.name;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatComponentName(instance, Component, isRoot = false) {\r\n    let name = getComponentName(Component);\r\n    if (!name && Component.__file) {\r\n        const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\r\n        if (match) {\r\n            name = match[1];\r\n        }\r\n    }\r\n    if (!name && instance && instance.parent) {\r\n        // try to infer the name based on reverse resolution\r\n        const inferFromRegistry = (registry) => {\r\n            for (const key in registry) {\r\n                if (registry[key] === Component) {\r\n                    return key;\r\n                }\r\n            }\r\n        };\r\n        name =\r\n            inferFromRegistry(instance.components ||\r\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\r\n    }\r\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\r\n}\n\nfunction ssrRenderList(source, renderItem) {\r\n    if (isArray(source) || isString(source)) {\r\n        for (let i = 0, l = source.length; i < l; i++) {\r\n            renderItem(source[i], i);\r\n        }\r\n    }\r\n    else if (typeof source === 'number') {\r\n        if ((process.env.NODE_ENV !== 'production') && !Number.isInteger(source)) {\r\n            warn(`The v-for range expect an integer value but got ${source}.`);\r\n            return;\r\n        }\r\n        for (let i = 0; i < source; i++) {\r\n            renderItem(i + 1, i);\r\n        }\r\n    }\r\n    else if (isObject(source)) {\r\n        if (source[Symbol.iterator]) {\r\n            const arr = Array.from(source);\r\n            for (let i = 0, l = arr.length; i < l; i++) {\r\n                renderItem(arr[i], i);\r\n            }\r\n        }\r\n        else {\r\n            const keys = Object.keys(source);\r\n            for (let i = 0, l = keys.length; i < l; i++) {\r\n                const key = keys[i];\r\n                renderItem(source[key], key, i);\r\n            }\r\n        }\r\n    }\r\n}\n\nasync function ssrRenderSuspense(push, { default: renderContent }) {\r\n    if (renderContent) {\r\n        renderContent();\r\n    }\r\n    else {\r\n        push(`<!---->`);\r\n    }\r\n}\n\nfunction ssrGetDirectiveProps(instance, dir, value, arg, modifiers = {}) {\r\n    if (typeof dir !== 'function' && dir.getSSRProps) {\r\n        return (dir.getSSRProps({\r\n            dir,\r\n            instance,\r\n            value,\r\n            oldValue: undefined,\r\n            arg,\r\n            modifiers\r\n        }, null) || {});\r\n    }\r\n    return {};\r\n}\n\nconst ssrLooseEqual = looseEqual;\r\nfunction ssrLooseContain(arr, value) {\r\n    return looseIndexOf(arr, value) > -1;\r\n}\r\n// for <input :type=\"type\" v-model=\"model\" value=\"value\">\r\nfunction ssrRenderDynamicModel(type, model, value) {\r\n    switch (type) {\r\n        case 'radio':\r\n            return looseEqual(model, value) ? ' checked' : '';\r\n        case 'checkbox':\r\n            return (isArray(model) ? ssrLooseContain(model, value) : model)\r\n                ? ' checked'\r\n                : '';\r\n        default:\r\n            // text types\r\n            return ssrRenderAttr('value', model);\r\n    }\r\n}\r\n// for <input v-bind=\"obj\" v-model=\"model\">\r\nfunction ssrGetDynamicModelProps(existingProps = {}, model) {\r\n    const { type, value } = existingProps;\r\n    switch (type) {\r\n        case 'radio':\r\n            return looseEqual(model, value) ? { checked: true } : null;\r\n        case 'checkbox':\r\n            return (isArray(model) ? ssrLooseContain(model, value) : model)\r\n                ? { checked: true }\r\n                : null;\r\n        default:\r\n            // text types\r\n            return { value: model };\r\n    }\r\n}\n\ninitDirectivesForSSR();\n\nexport { pipeToNodeWritable, pipeToWebWritable, renderToNodeStream, renderToSimpleStream, renderToStream, renderToString, renderToWebStream, ssrGetDirectiveProps, ssrGetDynamicModelProps, ssrInterpolate, ssrLooseContain, ssrLooseEqual, ssrRenderAttr, ssrRenderAttrs, ssrRenderClass, ssrRenderComponent, ssrRenderDynamicAttr, ssrRenderDynamicModel, ssrRenderList, ssrRenderSlot, ssrRenderSlotInner, ssrRenderStyle, ssrRenderSuspense, ssrRenderTeleport, renderVNode as ssrRenderVNode };\n", "// https://github.com/yahoo/serialize-javascript\nconst UNSAFE_CHARS_REGEXP = /[<>\\/\\u2028\\u2029]/g;\nconst ESCAPED_CHARS = {\n    '<': '\\\\u003C',\n    '>': '\\\\u003E',\n    '/': '\\\\u002F',\n    '\\u2028': '\\\\u2028',\n    '\\u2029': '\\\\u2029',\n};\nfunction escapeUnsafeChars(unsafeChar) {\n    return ESCAPED_CHARS[unsafeChar];\n}\nexport function serializeState(state) {\n    try {\n        // -- Example:\n        // Input object: { hello: 'w\\'or\"ld  -  <script>' }\n        // Output string: '{\"hello\":\"w\\'or\\\\\"ld  -  \\u003Cscript\\u003E\"}'\n        state = JSON.stringify(state || {})\n            // 1. Duplicate the escape char (\\) for already escaped characters (e.g. \\n or \\\").\n            .replace(/\\\\/g, String.raw `\\\\`)\n            // 2. Escape existing single quotes to allow wrapping the whole thing in '...'.\n            // Because we are doing the JSON.stringify ourselves (i.e., we're not taking a JSON string as a parameter, in\n            // which case we wouldn't know if there is redundant escaping), it's safe to use a regular expression for this.\n            .replace(/'/g, String.raw `\\'`)\n            // 3. Escape unsafe chars.\n            .replace(UNSAFE_CHARS_REGEXP, escapeUnsafeChars);\n        // Wrap the serialized JSON in quotes so that it's parsed\n        // by the browser as a string for better performance.\n        return `'${state}'`;\n    }\n    catch (error) {\n        console.error('[SSR] On state serialization -', error, state);\n        return '{}';\n    }\n}\n", "export function findDependencies(modules, manifest) {\n    const files = new Set();\n    for (const id of modules || []) {\n        for (const file of manifest[id] || []) {\n            files.add(file);\n        }\n    }\n    return [...files];\n}\nexport function renderPreloadLinks(files) {\n    let link = '';\n    for (const file of files || []) {\n        if (file.endsWith('.js')) {\n            link += `<link rel=\"modulepreload\" crossorigin href=\"${file}\">`;\n        }\n        else if (file.endsWith('.css')) {\n            link += `<link rel=\"stylesheet\" href=\"${file}\">`;\n        }\n    }\n    return link;\n}\n// @ts-ignore\nconst containerId = __CONTAINER_ID__;\nconst containerRE = new RegExp(`<div id=\"${containerId}\"([\\\\s\\\\w\\\\-\"'=[\\\\]]*)><\\\\/div>`);\nexport function buildHtmlDocument(template, { htmlAttrs, bodyAttrs, headTags, body, initialState }) {\n    // @ts-ignore\n    if (__DEV__) {\n        if (template.indexOf(`id=\"${containerId}\"`) === -1) {\n            console.warn(`[SSR] Container with id \"${containerId}\" was not found in index.html`);\n        }\n    }\n    if (htmlAttrs) {\n        template = template.replace('<html', `<html ${htmlAttrs} `);\n    }\n    if (bodyAttrs) {\n        template = template.replace('<body', `<body ${bodyAttrs} `);\n    }\n    if (headTags) {\n        template = template.replace('</head>', `\\n${headTags}\\n</head>`);\n    }\n    return template.replace(containerRE, \n    // Use function parameter here to avoid replacing `$1` in body or initialState.\n    // https://github.com/frandiox/vite-ssr/issues/123\n    (_, d1) => `<div id=\"${containerId}\" data-server-rendered=\"true\"${d1 || ''}>${body || ''}</div>\\n\\n  <script>window.__INITIAL_STATE__=${initialState || \"'{}'\"}</script>`);\n}\n", "import { createUrl } from '../utils/route';\nimport { useSsrResponse } from '../utils/response';\nimport { serializeState } from '../utils/serialize-state';\nimport { buildHtmlDocument, findDependencies, renderPreloadLinks, } from '../utils/html';\nconst getEmptyHtmlParts = () => ({\n    headTags: '',\n    htmlAttrs: '',\n    bodyAttrs: '',\n    body: '',\n    initialState: undefined,\n    dependencies: [],\n});\nexport const viteSSR = function viteSSR(options, hook) {\n    const renderer = hook || options;\n    const { transformState = serializeState } = options;\n    return async function (url, { manifest, preload = false, skip = false, template = `__VITE_SSR_HTML__`, // This string is transformed at build time\n    ...extra } = {}) {\n        if (skip) {\n            return { html: template, ...getEmptyHtmlParts() };\n        }\n        url = createUrl(url);\n        // Server redirect utilities\n        const { deferred, response, writeResponse, redirect, isRedirect } = useSsrResponse();\n        const context = {\n            url,\n            isClient: false,\n            initialState: {},\n            redirect,\n            writeResponse,\n            ...extra,\n        };\n        // Wait for either rendering finished or redirection detected\n        const payload = await Promise.race([\n            renderer(context, { ...extra, isRedirect }),\n            deferred.promise, // Resolves when 'redirect' is called\n        ]);\n        // The 'redirect' utility has been called during rendering: skip everything else\n        if (isRedirect())\n            return response;\n        // Not a redirect: get the HTML parts returned by the renderer and continue\n        const htmlParts = {\n            ...getEmptyHtmlParts(),\n            ...payload,\n            // Serialize the state to include it in the DOM\n            initialState: await transformState(context.initialState || {}, serializeState),\n        };\n        // If a manifest is provided and the current framework is able to add\n        // modules to the context (e.g. Vue) while rendering, collect the dependencies.\n        if (manifest) {\n            htmlParts.dependencies = findDependencies(context.modules, manifest);\n            if (preload && htmlParts.dependencies.length > 0) {\n                htmlParts.headTags += renderPreloadLinks(htmlParts.dependencies);\n            }\n        }\n        return {\n            html: buildHtmlDocument(template, htmlParts),\n            ...htmlParts,\n            ...response,\n        };\n    };\n};\nexport default viteSSR;\n", "import { createApp } from 'vue';\nimport { renderToString } from '@vue/server-renderer';\nimport { createRouter, createMemoryHistory } from 'vue-router';\nimport { getFullPath, withoutSuffix } from '../utils/route';\nimport { addPagePropsGetterToRoutes } from './utils';\nimport { renderHeadToString } from '@vueuse/head';\nimport coreViteSSR from '../core/entry-server.js';\nimport { provideContext } from './components.js';\nexport { ClientOnly, useContext } from './components.js';\nexport const viteSSR = function viteSSR(App, { routes, base, routerOptions = {}, pageProps = { passToPage: true }, ...options }, hook) {\n    if (pageProps && pageProps.passToPage) {\n        addPagePropsGetterToRoutes(routes);\n    }\n    return coreViteSSR(options, async (context, { isRedirect, ...extra }) => {\n        const app = createApp(App);\n        const routeBase = base && withoutSuffix(base(context), '/');\n        const router = createRouter({\n            ...routerOptions,\n            history: createMemoryHistory(routeBase),\n            routes: routes,\n        });\n        router.beforeEach((to) => {\n            to.meta.state = extra.initialState || null;\n        });\n        provideContext(app, context);\n        const fullPath = getFullPath(context.url, routeBase);\n        const { head } = (hook &&\n            (await hook({\n                app,\n                router,\n                initialRoute: router.resolve(fullPath),\n                ...context,\n            }))) ||\n            {};\n        app.use(router);\n        router.push(fullPath);\n        await router.isReady();\n        if (isRedirect())\n            return {};\n        Object.assign(context.initialState || {}, (router.currentRoute.value.meta || {}).state || {});\n        const body = await renderToString(app, context);\n        if (isRedirect())\n            return {};\n        const { headTags = '', htmlAttrs = '', bodyAttrs = '', } = head ? renderHeadToString(head) : {};\n        return { body, headTags, htmlAttrs, bodyAttrs };\n    });\n};\nexport default viteSSR;\n", "import d from \"./node_modules/vite-ssr/vue/entry-server.js\";export default d;\nexport * from \"./node_modules/vite-ssr/vue/entry-server.js\""],
  "mappings": "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",
  "names": []
}
